% equal with the given parameter N.
% generatePair(N - integer, X - integer, Y - integer)
% generatePair(i,o,o)
% generatePair(N) = { (X,Y), X<Y && X+Y=N}
generatePair(N, X, Y) :-
    my_between(1, N, Y),
    my_between(1, N, X),
    X < Y,
    N =:= X + Y.

% This predicate decomposes the given number N into a list of integers
% such that their sum is equal to N.
% decomposeNumber(N - integer, L - list)
% decomposeNumber(i,o)

decomposeNumber(N, [N]).
decomposeNumber(N, [X|L]) :- generatePair(N, X, Y), decomposeNumber(Y, L).

% This predicate checks it the that elements in the given list have
% consecutive value.
% isConsecutive(L - list)
% isConsecutive(i)
% isConsecutive([l1,l2,..,ln]) = { true, L=[l1,l2] && l1+1=l2
%                                { isConsecutive(l2..ln), l1+1=l2 && n>2
%                                { false, otherwise
isConsecutive([X,Y]):-X+1=:=Y.
isConsecutive([H1,H2|T]):-H2=:=H1+1, isConsecutive([H2|T]).

nAsSumOfConsecutives(N,L):-decomposeNumber(N,X), isConsecutive(X), L=X.

main(N,L):-findall(R,nAsSumOfConsecutives(N,R),L).